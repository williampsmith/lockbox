

User: username, password, RSA Private Key, RSA Public Key, OwnedFiles, SharedFiles

Keys for the user:
Ke, Ka are symmetric master keys specific to each user and are generated using PBKDF2(password, salt=SHA256(username), 2 x AESKeySize)
Ke is the first 16 bytes and Ka is the second 16 bytes of PBKDF2
Ke is used for encrypting and decrypting
Ka is used for authenticating

Keys for file storage:
FileKeys: FileID, Ke',Ka'
SharedMetaData: FileSize (uint), numRevisions (uint), RevisionSizes ([]uint)
FileID is a randomly generated uuid and Ke', Ka' are randomly generated 16 byte keys
FileSize is the total length of the cipher text, numRevisions is number of appends + 1, RevisionSizes is an array of size of ciphertext of each append


Datastore paths are computed as follows:
"logins/" || UserID; UserID = HMAC(Ka, username)
"meta/" || FileID
"file/" || FileID

Overall Datastore Structure
	"logins/<UserID>" : c || HMAC(Ka, c)													where c = CFBEncrypt(Ke, userdata)
	"meta/<FileID>"	  : metadata || HMAC(Ka', metadata)										where metadata = (FileSize, numRevisions, RevisionSizes)
	"file/<FileID>"   : HMAC(Ka', c_0 || 0) || c_0 || HMAC(Ka', c_1 || 1) || c_1 || ...		where c_i =  CFBEncrypt(Ke', fileplaintext_i)

		In "file/<FileID>", we concatenate with index (0, 1, ...) to prevent attacker from swapping the contents

		Ke is used for encrypting and decrypting
		Ka is used for authenticating
		Ke, Ka are unique to each user and retreived using PBKDF2
		FileID, Ke', Ka' are unique to each file and are randomly generated
		Every user who has access to a file stores (FileID, Ke', Ka') in their User struct in OwnedFiles[filename] or SharedFiles[filename]

InitUser
	- Compute Ke and Ka from PBKDF2
	- Generate RSA Private and RSA Public keys
	- Keystore to KeystoreSet: (username, RSA Public key)
	- Datastore to "logins/<UserID>": c || HMAC(Ka, c) where c = CFBEncrypt(Ke, userdata)

GetUser
	- Compute Ke and Ka from PBKDF2
	- Get from "logins/<userID>": c || HMAC(Ka, c)
	- Verify: compute HMAC(Ka, c) and compare to what was stored
	- User's userdata = CFBDecrypt(Ke, c)
	- Return userdata

StoreFile
	- Generate random (FileID, Ke', Ka')
	- Store (FileID, Ke', Ka') in User's OwnedFiles[filename]
	- c = CFBEncrypt(Ke', file contents)
	- metaData = (len(c), numRevisions{1}, RevisionSizes{[len(c)]})
	- Datastore to "meta/<FileID>": metadata || HMAC(Ka', metadata)
	- Datastore to "file/<FileID>": HMAC(Ka', c || index) || c

AppendFile
	- Get metadata from "meta/<FileID>"
	- Verify HMAC(Ka', metadata)
	- c = CFBEncrypt(Ke', append contents)
	- Modify metadata: (length += len(c), numRevisions++, ReivisionSizes.append(len(c))
	- Datastore to "meta/<FileID>": metadata || HMAC(Ka', metadata)
	- Append to file at "file/<FileID>" : HMAC(Ka', c || index) || c

LoadFile
	- Get metadata from "meta/<FileID>"
	- Verify HMAC(Ka', metadata)
	- Get ciphertext chunks from "file/<FileID>"
	- Using metadata, iterate through ciphertext chunks
		- Read each HMAC(Ka', c_i || index) || c_i
		- Verify each HMAC(Ka', c_i || index)
	- Return the concatenatation of every plaintext_i = CFBDecrypt(Ke', c_i)

ShareFile
	- Get (FileID, Ke', Ka') from User's OwnedFiles[filename] or SharedFiles[filename]
	- c = RSAEncrypt(Recipient public key, (FileID, Ke', Ka'))
	- sig = RSASign(Sender private key, c)
	- Return c || sig

ReceiveFile
	- RSAVerify(Sender public key, c)
	- (FileID, Ke', Ka') = RSADecrypt(Recipient private key, c)
	- Store (FileID, Ke', Ka') in User's SharedFiles[filename]

RevokeFile
	- Owner check: check if file is in User's OwnedFiles[filename]
	- Get original file plaintext by calling LoadFile on filename
	- Re-encrypt original Datastore location with random keys so no one can read or authenticate it
		- Generate random Ke'', Ka''
		- Re-encrypt and re-authenticate contents at "file/<FileID>" with Ke'', Ka''
		- Modify and re-authenticate contents at "meta/<FileID>" with Ke''
	- Call DatastoreDelete on "file/<FileID>" and "meta/<FileID>"
	- Call StoreFile on original file plaintext, StoreFile will generate a new random (FileID, Ke', Ka') for the User



Security Analysis

Data Swap Attack: The malicious server does not know the contents of the file, nor the name of the file,
but can see that file/<r> corresponds to meta/<r>, and hence perform a swap of the data at
file/<r1> with the data at file/<r2>, and to avoid detection, swap the data at meta<r1> with
the data at meta/<r2>. This exploit will fail, however, because we have a unique MAC key corresponding
to each individual file which MAC's the file and the associated metadata. This MAC is stored in the
user's revisionMetaData struct within the User struct. Since this has not been swapped, the MAC's will fail.

Filename Dictionary Attack: The malicious server attempts to identify the file by keying on known filenames,
or precomputed hash values of known filenames. This will fail, because the filename is generated as a random
UUID, which is saved as file metadata within the User struct, and only shared via RSA encryption to shared users.
Therefore, to break the filename, the server must break the encryption on the User struct.

ShareFile Man in the Middle Attack: Some external attacker mounts a man in the middle attack on the communication channel
between two users sharing a message. If the attacker tries to eavesdrop, it will fail, due to the data being encrypted by RSA.
To decrypt, the attacker would need to know the recipient's private key, which would require breaking the block cipher encryption
of his User struct. If the attacker tries to tamper with the message it will fail, due to the data containing an RSA Signature.
In order to tamper with it and resign, the attacker would need to know the sender's private key, which would require breaking the
block cipher encryption of her User struct.
